
// Local dependencies
const { Collection  , Client } = require('discord.js')

const GinkoError = require('../Util/GinkoError')

const { CommandModule} = require('../Module/ModuloComando')

const { EventModule } = require('../Module/ModuloEvento')

const getObjects = require('../Usage/getObjects')

const getFile = require('../Usage/getFile')

const clientUtil = require('../Usage/clientUtil')

// Datos para los comandos,eventos y utilidad
const Comandos = new Collection();

const ComandosOptions = new Array();

const Eventos = new Array();

const CommandWatch = new Array();


class GinkoClient extends Client {

    constructor(opciones = {}, clientOptions) {
        super(clientOptions || opciones)
        /**
         * La id del dueÃ±o
         * @type {string}
        */
        this.ownerID = opciones.ownerID;
        /**
         * La ruta para la carpeta de comandos
         * @type {string}
        */
        this.carpetaComandos = opciones.carpetaComandos;
        /**
         * la ruta para la carpeta de eventos
         * @type {string}
        */
       this.carpetaEventos = opciones.carpetaEventos;
        /**
         * El prefijo
         * @type {string}
        */
        this.prefijo = opciones.prefijo;
         /**
         * La lista negra de usuarios
         * @type {string}
        */
       this.blacklist = opciones.blacklist || [];
    }
    // La funcion login, practicamente maneja todo
   async login(token){

        if(!this.prefijo) throw new GinkoError("Tienes que poner un prefijo en las opciones.")

    // Una vez que entro, en marcha todas la funciones
        super.login(token).then( async () => {
            
            this.util = new Object();

            //Funcion linda, para recargar cualquier comando 
            this.recargarComando = (comando) => {
                if(typeof comando !== "string") throw new GinkoError('El parametro de recargarComando() tiene que ser una String')

                if(getFile(this.carpetaComandos, comando) === false) return console.log("SEMI-ERROR: Sucedio algo inseperado al obtener datos para la Utilidad, por favor, avisar a ManU#0001, codigo del error: 002")
                Comandos.sweep(p => p == comando)

                delete require.cache[require.resolve(`${process.cwd()}\\${this.carpetaComandos.substr(2)}\\${getFile(this.carpetaComandos, comando)}`)]

                let pp = require(`${process.cwd()}\\${this.carpetaComandos.substr(2)}\\${getFile(this.carpetaComandos, comando)}`);

                Comandos.set(pp.nombre , pp.run);
            }
           
            this.util.obtenerUsuario = (user) => clientUtil.obtenerUsuario(this, user)
            this.util.obtenerMiembro = (guild, miembro) => clientUtil.obtenerMiembro(guild ,miembro)
            this.util.pedirRespuesta = (canal,user,tiempo,si,no) => clientUtil.pedirRespuesta(canal,user,tiempo,si,no)

            console.log('\n')
            EventModule(this.carpetaEventos, Eventos)
            CommandModule(this.carpetaComandos , Comandos, ComandosOptions, CommandWatch)
            
            this.commandUtil = CommandWatch;

            const cooldown = new Array();

            this.on('message', async message => { 

                if(this.blacklist.includes(message.author.id)) return;

                var prefijo;
                // Ver si el prefijo es estatico o no
                if (typeof this.prefijo === "function") prefijo = await this.prefijo(message)
                else prefijo = this.prefijo

                // Cosas basicas del evento mensaje que ejecuta los comandos
                if(message.author.bot) return;
                
                if (message.content.indexOf(prefijo) !== 0) return;

                let mensajes = message.content.split(" ");
                let cmd = mensajes[0]

                var args = mensajes.slice(1);

                if(args.length == 0) args = false

                let cmdarchivo = Comandos.get(cmd.slice(prefijo.length));

                var comandoN = cmd.slice(prefijo.length)
                

                for (let i = 0; i < ComandosOptions.length; i++){
                    if(ComandosOptions.find(c=> c.alias[i] == comandoN)) var findAlias = ComandosOptions.find(c=> c.alias[i] == comandoN)

                } 

                if(findAlias) {
                    var alias = findAlias.nombre
                    cmdarchivo = Comandos.get(alias)
                } 
               
                if (cmdarchivo || findAlias){
                  let options = getObjects(ComandosOptions, "nombre", alias ?  alias : comandoN)
                    if(options[0].ownerOnly == true) {

                        if(message.author.id !== this.ownerID) return;
                        cmdarchivo(this, message, args)

                    }else if(options[0].cooldown[0] == true){

                        if(options[0].permiso !== false) {
                            if(!options[0].permiso instanceof Array) throw new GinkoError("Los permisos tienen que estar en un array")
                            if(!message.member.hasPermission(options[0].permiso)) return
                        }

                        if(cooldown.find(c => c.Uid == message.author.id && c.Cname == comandoN))  return options[0].cooldown[2] ? message.channel.send(options[0].cooldown[2]) : " "
                        cmdarchivo(this, message, args)
                        cooldown.push({Uid: message.author.id , Cname: comandoN})
                        if(isNaN(parseInt(options[0].cooldown[1]))) throw new GinkoError("El tiempo del cooldown tiene que ser un numero")
                        setTimeout(() => {

                           let remove = cooldown.findIndex(c => c.Uid == message.author.id && c.Cname == comandoN)
                           cooldown.splice(remove , 1)

                        }, parseInt(options[0].cooldown[1]));

                    }else if(options[0].permiso !== false) {
                        if(options[0].permiso.respuesta) {
                            if(!message.member.hasPermission(options[0].permiso.permisos)) return message.channel.send(options[0].permiso.respuesta)
                        }
                        else if(!message.member.hasPermission(options[0].permiso.permisos)) return;
                        cmdarchivo(this, message, args)
                        
                    }else cmdarchivo(this, message, args)
                }
                });

                Eventos.forEach( event => {
                    if(event.evento == "ready") return event.run(this)
                    this.on(event.evento, event.run)
                })
                
        }).catch(e => {
            throw e
        })
    }
}
module.exports = GinkoClient;